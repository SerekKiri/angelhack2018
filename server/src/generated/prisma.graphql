# source: http://localhost:4466
# timestamp: Sat May 19 2018 14:09:16 GMT+0200 (CEST)

type AggregateCheckboxField {
  count: Int!
}

type AggregateDocumentTemplate {
  count: Int!
}

type AggregateFieldHeader {
  count: Int!
}

type AggregateTextField {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  """The number of nodes that have been affected by the Batch operation."""
  count: Long!
}

type CheckboxField implements Node {
  id: ID!
  label: String!
  defaultValue: Boolean!
}

"""A connection to a list of items."""
type CheckboxFieldConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [CheckboxFieldEdge]!
  aggregate: AggregateCheckboxField!
}

input CheckboxFieldCreateInput {
  label: String!
  defaultValue: Boolean!
}

input CheckboxFieldCreateManyInput {
  create: [CheckboxFieldCreateInput!]
  connect: [CheckboxFieldWhereUniqueInput!]
}

"""An edge in a connection."""
type CheckboxFieldEdge {
  """The item at the end of the edge."""
  node: CheckboxField!

  """A cursor for use in pagination."""
  cursor: String!
}

enum CheckboxFieldOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  defaultValue_ASC
  defaultValue_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type CheckboxFieldPreviousValues {
  id: ID!
  label: String!
  defaultValue: Boolean!
}

type CheckboxFieldSubscriptionPayload {
  mutation: MutationType!
  node: CheckboxField
  updatedFields: [String!]
  previousValues: CheckboxFieldPreviousValues
}

input CheckboxFieldSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [CheckboxFieldSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [CheckboxFieldSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CheckboxFieldSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: CheckboxFieldWhereInput
}

input CheckboxFieldUpdateDataInput {
  label: String
  defaultValue: Boolean
}

input CheckboxFieldUpdateInput {
  label: String
  defaultValue: Boolean
}

input CheckboxFieldUpdateManyInput {
  create: [CheckboxFieldCreateInput!]
  connect: [CheckboxFieldWhereUniqueInput!]
  disconnect: [CheckboxFieldWhereUniqueInput!]
  delete: [CheckboxFieldWhereUniqueInput!]
  update: [CheckboxFieldUpdateWithWhereUniqueNestedInput!]
  upsert: [CheckboxFieldUpsertWithWhereUniqueNestedInput!]
}

input CheckboxFieldUpdateWithWhereUniqueNestedInput {
  where: CheckboxFieldWhereUniqueInput!
  data: CheckboxFieldUpdateDataInput!
}

input CheckboxFieldUpsertWithWhereUniqueNestedInput {
  where: CheckboxFieldWhereUniqueInput!
  update: CheckboxFieldUpdateDataInput!
  create: CheckboxFieldCreateInput!
}

input CheckboxFieldWhereInput {
  """Logical AND on all given filters."""
  AND: [CheckboxFieldWhereInput!]

  """Logical OR on all given filters."""
  OR: [CheckboxFieldWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [CheckboxFieldWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  label: String

  """All values that are not equal to given value."""
  label_not: String

  """All values that are contained in given list."""
  label_in: [String!]

  """All values that are not contained in given list."""
  label_not_in: [String!]

  """All values less than the given value."""
  label_lt: String

  """All values less than or equal the given value."""
  label_lte: String

  """All values greater than the given value."""
  label_gt: String

  """All values greater than or equal the given value."""
  label_gte: String

  """All values containing the given string."""
  label_contains: String

  """All values not containing the given string."""
  label_not_contains: String

  """All values starting with the given string."""
  label_starts_with: String

  """All values not starting with the given string."""
  label_not_starts_with: String

  """All values ending with the given string."""
  label_ends_with: String

  """All values not ending with the given string."""
  label_not_ends_with: String
  defaultValue: Boolean

  """All values that are not equal to given value."""
  defaultValue_not: Boolean
}

input CheckboxFieldWhereUniqueInput {
  id: ID
}

type DocumentTemplate implements Node {
  id: ID!
  fieldHeaders(where: FieldHeaderWhereInput, orderBy: FieldHeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FieldHeader!]
  checkboxFields(where: CheckboxFieldWhereInput, orderBy: CheckboxFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CheckboxField!]
  textFields(where: TextFieldWhereInput, orderBy: TextFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TextField!]
}

"""A connection to a list of items."""
type DocumentTemplateConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [DocumentTemplateEdge]!
  aggregate: AggregateDocumentTemplate!
}

input DocumentTemplateCreateInput {
  fieldHeaders: FieldHeaderCreateManyInput
  checkboxFields: CheckboxFieldCreateManyInput
  textFields: TextFieldCreateManyInput
}

"""An edge in a connection."""
type DocumentTemplateEdge {
  """The item at the end of the edge."""
  node: DocumentTemplate!

  """A cursor for use in pagination."""
  cursor: String!
}

enum DocumentTemplateOrderByInput {
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type DocumentTemplatePreviousValues {
  id: ID!
}

type DocumentTemplateSubscriptionPayload {
  mutation: MutationType!
  node: DocumentTemplate
  updatedFields: [String!]
  previousValues: DocumentTemplatePreviousValues
}

input DocumentTemplateSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [DocumentTemplateSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [DocumentTemplateSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [DocumentTemplateSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: DocumentTemplateWhereInput
}

input DocumentTemplateUpdateInput {
  fieldHeaders: FieldHeaderUpdateManyInput
  checkboxFields: CheckboxFieldUpdateManyInput
  textFields: TextFieldUpdateManyInput
}

input DocumentTemplateWhereInput {
  """Logical AND on all given filters."""
  AND: [DocumentTemplateWhereInput!]

  """Logical OR on all given filters."""
  OR: [DocumentTemplateWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [DocumentTemplateWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  fieldHeaders_every: FieldHeaderWhereInput
  fieldHeaders_some: FieldHeaderWhereInput
  fieldHeaders_none: FieldHeaderWhereInput
  checkboxFields_every: CheckboxFieldWhereInput
  checkboxFields_some: CheckboxFieldWhereInput
  checkboxFields_none: CheckboxFieldWhereInput
  textFields_every: TextFieldWhereInput
  textFields_some: TextFieldWhereInput
  textFields_none: TextFieldWhereInput
}

input DocumentTemplateWhereUniqueInput {
  id: ID
}

type FieldHeader {
  type: FieldType!
  order: Int!
  definitionId: ID!
}

"""A connection to a list of items."""
type FieldHeaderConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [FieldHeaderEdge]!
  aggregate: AggregateFieldHeader!
}

input FieldHeaderCreateInput {
  type: FieldType!
  order: Int!
  definitionId: ID!
}

input FieldHeaderCreateManyInput {
  create: [FieldHeaderCreateInput!]
}

"""An edge in a connection."""
type FieldHeaderEdge {
  """The item at the end of the edge."""
  node: FieldHeader!

  """A cursor for use in pagination."""
  cursor: String!
}

enum FieldHeaderOrderByInput {
  type_ASC
  type_DESC
  order_ASC
  order_DESC
  definitionId_ASC
  definitionId_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type FieldHeaderPreviousValues {
  type: FieldType!
  order: Int!
  definitionId: ID!
}

type FieldHeaderSubscriptionPayload {
  mutation: MutationType!
  node: FieldHeader
  updatedFields: [String!]
  previousValues: FieldHeaderPreviousValues
}

input FieldHeaderSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [FieldHeaderSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [FieldHeaderSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FieldHeaderSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: FieldHeaderWhereInput
}

input FieldHeaderUpdateInput {
  type: FieldType
  order: Int
  definitionId: ID
}

input FieldHeaderUpdateManyInput {
  create: [FieldHeaderCreateInput!]
}

input FieldHeaderWhereInput {
  """Logical AND on all given filters."""
  AND: [FieldHeaderWhereInput!]

  """Logical OR on all given filters."""
  OR: [FieldHeaderWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [FieldHeaderWhereInput!]
  type: FieldType

  """All values that are not equal to given value."""
  type_not: FieldType

  """All values that are contained in given list."""
  type_in: [FieldType!]

  """All values that are not contained in given list."""
  type_not_in: [FieldType!]
  order: Int

  """All values that are not equal to given value."""
  order_not: Int

  """All values that are contained in given list."""
  order_in: [Int!]

  """All values that are not contained in given list."""
  order_not_in: [Int!]

  """All values less than the given value."""
  order_lt: Int

  """All values less than or equal the given value."""
  order_lte: Int

  """All values greater than the given value."""
  order_gt: Int

  """All values greater than or equal the given value."""
  order_gte: Int
  definitionId: ID

  """All values that are not equal to given value."""
  definitionId_not: ID

  """All values that are contained in given list."""
  definitionId_in: [ID!]

  """All values that are not contained in given list."""
  definitionId_not_in: [ID!]

  """All values less than the given value."""
  definitionId_lt: ID

  """All values less than or equal the given value."""
  definitionId_lte: ID

  """All values greater than the given value."""
  definitionId_gt: ID

  """All values greater than or equal the given value."""
  definitionId_gte: ID

  """All values containing the given string."""
  definitionId_contains: ID

  """All values not containing the given string."""
  definitionId_not_contains: ID

  """All values starting with the given string."""
  definitionId_starts_with: ID

  """All values not starting with the given string."""
  definitionId_not_starts_with: ID

  """All values ending with the given string."""
  definitionId_ends_with: ID

  """All values not ending with the given string."""
  definitionId_not_ends_with: ID
}

enum FieldType {
  TEXT
  CHECKBOX
  MARKDOWN
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type Mutation {
  createUser(data: UserCreateInput!): User!
  createFieldHeader(data: FieldHeaderCreateInput!): FieldHeader!
  createCheckboxField(data: CheckboxFieldCreateInput!): CheckboxField!
  createTextField(data: TextFieldCreateInput!): TextField!
  createDocumentTemplate(data: DocumentTemplateCreateInput!): DocumentTemplate!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateCheckboxField(data: CheckboxFieldUpdateInput!, where: CheckboxFieldWhereUniqueInput!): CheckboxField
  updateTextField(data: TextFieldUpdateInput!, where: TextFieldWhereUniqueInput!): TextField
  updateDocumentTemplate(data: DocumentTemplateUpdateInput!, where: DocumentTemplateWhereUniqueInput!): DocumentTemplate
  deleteUser(where: UserWhereUniqueInput!): User
  deleteCheckboxField(where: CheckboxFieldWhereUniqueInput!): CheckboxField
  deleteTextField(where: TextFieldWhereUniqueInput!): TextField
  deleteDocumentTemplate(where: DocumentTemplateWhereUniqueInput!): DocumentTemplate
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  upsertCheckboxField(where: CheckboxFieldWhereUniqueInput!, create: CheckboxFieldCreateInput!, update: CheckboxFieldUpdateInput!): CheckboxField!
  upsertTextField(where: TextFieldWhereUniqueInput!, create: TextFieldCreateInput!, update: TextFieldUpdateInput!): TextField!
  upsertDocumentTemplate(where: DocumentTemplateWhereUniqueInput!, create: DocumentTemplateCreateInput!, update: DocumentTemplateUpdateInput!): DocumentTemplate!
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput): BatchPayload!
  updateManyFieldHeaders(data: FieldHeaderUpdateInput!, where: FieldHeaderWhereInput): BatchPayload!
  updateManyCheckboxFields(data: CheckboxFieldUpdateInput!, where: CheckboxFieldWhereInput): BatchPayload!
  updateManyTextFields(data: TextFieldUpdateInput!, where: TextFieldWhereInput): BatchPayload!
  updateManyDocumentTemplates(data: DocumentTemplateUpdateInput!, where: DocumentTemplateWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteManyFieldHeaders(where: FieldHeaderWhereInput): BatchPayload!
  deleteManyCheckboxFields(where: CheckboxFieldWhereInput): BatchPayload!
  deleteManyTextFields(where: TextFieldWhereInput): BatchPayload!
  deleteManyDocumentTemplates(where: DocumentTemplateWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Query {
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  fieldHeaders(where: FieldHeaderWhereInput, orderBy: FieldHeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FieldHeader]!
  checkboxFields(where: CheckboxFieldWhereInput, orderBy: CheckboxFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CheckboxField]!
  textFields(where: TextFieldWhereInput, orderBy: TextFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TextField]!
  documentTemplates(where: DocumentTemplateWhereInput, orderBy: DocumentTemplateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DocumentTemplate]!
  user(where: UserWhereUniqueInput!): User
  checkboxField(where: CheckboxFieldWhereUniqueInput!): CheckboxField
  textField(where: TextFieldWhereUniqueInput!): TextField
  documentTemplate(where: DocumentTemplateWhereUniqueInput!): DocumentTemplate
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  fieldHeadersConnection(where: FieldHeaderWhereInput, orderBy: FieldHeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FieldHeaderConnection!
  checkboxFieldsConnection(where: CheckboxFieldWhereInput, orderBy: CheckboxFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CheckboxFieldConnection!
  textFieldsConnection(where: TextFieldWhereInput, orderBy: TextFieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TextFieldConnection!
  documentTemplatesConnection(where: DocumentTemplateWhereInput, orderBy: DocumentTemplateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DocumentTemplateConnection!

  """Fetches an object given its ID"""
  node(
    """The ID of an object"""
    id: ID!
  ): Node
}

type Subscription {
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  fieldHeader(where: FieldHeaderSubscriptionWhereInput): FieldHeaderSubscriptionPayload
  checkboxField(where: CheckboxFieldSubscriptionWhereInput): CheckboxFieldSubscriptionPayload
  textField(where: TextFieldSubscriptionWhereInput): TextFieldSubscriptionPayload
  documentTemplate(where: DocumentTemplateSubscriptionWhereInput): DocumentTemplateSubscriptionPayload
}

type TextField implements Node {
  id: ID!
  label: String!
  defaultValue: String!
}

"""A connection to a list of items."""
type TextFieldConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [TextFieldEdge]!
  aggregate: AggregateTextField!
}

input TextFieldCreateInput {
  label: String!
  defaultValue: String!
}

input TextFieldCreateManyInput {
  create: [TextFieldCreateInput!]
  connect: [TextFieldWhereUniqueInput!]
}

"""An edge in a connection."""
type TextFieldEdge {
  """The item at the end of the edge."""
  node: TextField!

  """A cursor for use in pagination."""
  cursor: String!
}

enum TextFieldOrderByInput {
  id_ASC
  id_DESC
  label_ASC
  label_DESC
  defaultValue_ASC
  defaultValue_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type TextFieldPreviousValues {
  id: ID!
  label: String!
  defaultValue: String!
}

type TextFieldSubscriptionPayload {
  mutation: MutationType!
  node: TextField
  updatedFields: [String!]
  previousValues: TextFieldPreviousValues
}

input TextFieldSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [TextFieldSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [TextFieldSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TextFieldSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: TextFieldWhereInput
}

input TextFieldUpdateDataInput {
  label: String
  defaultValue: String
}

input TextFieldUpdateInput {
  label: String
  defaultValue: String
}

input TextFieldUpdateManyInput {
  create: [TextFieldCreateInput!]
  connect: [TextFieldWhereUniqueInput!]
  disconnect: [TextFieldWhereUniqueInput!]
  delete: [TextFieldWhereUniqueInput!]
  update: [TextFieldUpdateWithWhereUniqueNestedInput!]
  upsert: [TextFieldUpsertWithWhereUniqueNestedInput!]
}

input TextFieldUpdateWithWhereUniqueNestedInput {
  where: TextFieldWhereUniqueInput!
  data: TextFieldUpdateDataInput!
}

input TextFieldUpsertWithWhereUniqueNestedInput {
  where: TextFieldWhereUniqueInput!
  update: TextFieldUpdateDataInput!
  create: TextFieldCreateInput!
}

input TextFieldWhereInput {
  """Logical AND on all given filters."""
  AND: [TextFieldWhereInput!]

  """Logical OR on all given filters."""
  OR: [TextFieldWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [TextFieldWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  label: String

  """All values that are not equal to given value."""
  label_not: String

  """All values that are contained in given list."""
  label_in: [String!]

  """All values that are not contained in given list."""
  label_not_in: [String!]

  """All values less than the given value."""
  label_lt: String

  """All values less than or equal the given value."""
  label_lte: String

  """All values greater than the given value."""
  label_gt: String

  """All values greater than or equal the given value."""
  label_gte: String

  """All values containing the given string."""
  label_contains: String

  """All values not containing the given string."""
  label_not_contains: String

  """All values starting with the given string."""
  label_starts_with: String

  """All values not starting with the given string."""
  label_not_starts_with: String

  """All values ending with the given string."""
  label_ends_with: String

  """All values not ending with the given string."""
  label_not_ends_with: String
  defaultValue: String

  """All values that are not equal to given value."""
  defaultValue_not: String

  """All values that are contained in given list."""
  defaultValue_in: [String!]

  """All values that are not contained in given list."""
  defaultValue_not_in: [String!]

  """All values less than the given value."""
  defaultValue_lt: String

  """All values less than or equal the given value."""
  defaultValue_lte: String

  """All values greater than the given value."""
  defaultValue_gt: String

  """All values greater than or equal the given value."""
  defaultValue_gte: String

  """All values containing the given string."""
  defaultValue_contains: String

  """All values not containing the given string."""
  defaultValue_not_contains: String

  """All values starting with the given string."""
  defaultValue_starts_with: String

  """All values not starting with the given string."""
  defaultValue_not_starts_with: String

  """All values ending with the given string."""
  defaultValue_ends_with: String

  """All values not ending with the given string."""
  defaultValue_not_ends_with: String
}

input TextFieldWhereUniqueInput {
  id: ID
}

type User implements Node {
  id: ID!
  email: String!
  password: String!
  name: String!
}

"""A connection to a list of items."""
type UserConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String!
  password: String!
  name: String!
}

"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge."""
  node: User!

  """A cursor for use in pagination."""
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  name: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  """Logical AND on all given filters."""
  AND: [UserSubscriptionWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserSubscriptionWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserSubscriptionWhereInput!]

  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]

  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String

  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]

  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: UserWhereInput
}

input UserUpdateInput {
  email: String
  password: String
  name: String
}

input UserWhereInput {
  """Logical AND on all given filters."""
  AND: [UserWhereInput!]

  """Logical OR on all given filters."""
  OR: [UserWhereInput!]

  """Logical NOT on all given filters combined by AND."""
  NOT: [UserWhereInput!]
  id: ID

  """All values that are not equal to given value."""
  id_not: ID

  """All values that are contained in given list."""
  id_in: [ID!]

  """All values that are not contained in given list."""
  id_not_in: [ID!]

  """All values less than the given value."""
  id_lt: ID

  """All values less than or equal the given value."""
  id_lte: ID

  """All values greater than the given value."""
  id_gt: ID

  """All values greater than or equal the given value."""
  id_gte: ID

  """All values containing the given string."""
  id_contains: ID

  """All values not containing the given string."""
  id_not_contains: ID

  """All values starting with the given string."""
  id_starts_with: ID

  """All values not starting with the given string."""
  id_not_starts_with: ID

  """All values ending with the given string."""
  id_ends_with: ID

  """All values not ending with the given string."""
  id_not_ends_with: ID
  email: String

  """All values that are not equal to given value."""
  email_not: String

  """All values that are contained in given list."""
  email_in: [String!]

  """All values that are not contained in given list."""
  email_not_in: [String!]

  """All values less than the given value."""
  email_lt: String

  """All values less than or equal the given value."""
  email_lte: String

  """All values greater than the given value."""
  email_gt: String

  """All values greater than or equal the given value."""
  email_gte: String

  """All values containing the given string."""
  email_contains: String

  """All values not containing the given string."""
  email_not_contains: String

  """All values starting with the given string."""
  email_starts_with: String

  """All values not starting with the given string."""
  email_not_starts_with: String

  """All values ending with the given string."""
  email_ends_with: String

  """All values not ending with the given string."""
  email_not_ends_with: String
  password: String

  """All values that are not equal to given value."""
  password_not: String

  """All values that are contained in given list."""
  password_in: [String!]

  """All values that are not contained in given list."""
  password_not_in: [String!]

  """All values less than the given value."""
  password_lt: String

  """All values less than or equal the given value."""
  password_lte: String

  """All values greater than the given value."""
  password_gt: String

  """All values greater than or equal the given value."""
  password_gte: String

  """All values containing the given string."""
  password_contains: String

  """All values not containing the given string."""
  password_not_contains: String

  """All values starting with the given string."""
  password_starts_with: String

  """All values not starting with the given string."""
  password_not_starts_with: String

  """All values ending with the given string."""
  password_ends_with: String

  """All values not ending with the given string."""
  password_not_ends_with: String
  name: String

  """All values that are not equal to given value."""
  name_not: String

  """All values that are contained in given list."""
  name_in: [String!]

  """All values that are not contained in given list."""
  name_not_in: [String!]

  """All values less than the given value."""
  name_lt: String

  """All values less than or equal the given value."""
  name_lte: String

  """All values greater than the given value."""
  name_gt: String

  """All values greater than or equal the given value."""
  name_gte: String

  """All values containing the given string."""
  name_contains: String

  """All values not containing the given string."""
  name_not_contains: String

  """All values starting with the given string."""
  name_starts_with: String

  """All values not starting with the given string."""
  name_not_starts_with: String

  """All values ending with the given string."""
  name_ends_with: String

  """All values not ending with the given string."""
  name_not_ends_with: String
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
